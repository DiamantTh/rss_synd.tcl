package require tcltest 2
namespace import ::tcltest::*

# Stubs für Eggdrop-spezifische Funktionen
proc putlog {args} {}
proc putserv {args} {}
proc botonchan {chan} { return 1 }
proc is_utf8_patched {} { return 0 }
proc bind {args} {}
proc unbind {args} {}
proc unixtime {} { clock seconds }

set here [file dirname [info script]]
namespace eval ::rss-synd {}
source [file join $here .. rss_synd.tcl]

namespace eval ::http {
    variable lastUserAgents {}
    variable tokenCounter 0

    proc config {args} {
        variable lastUserAgents
        set index [lsearch -exact $args "-useragent"]
        if {$index >= 0} {
            lappend lastUserAgents [lindex $args [expr {$index + 1}]]
        }
        return {}
    }

    proc geturl {url args} {
        variable tokenCounter
        incr tokenCounter
        return "token$tokenCounter"
    }
}

namespace eval ::rss-synd { variable packages }

set sampleFeed {<rss><channel><title>Demo</title><item><title>Erster</title></item><item><title>Zweiter</title></item><item><title>Dritter</title></item></channel></rss>}

set parsedFeed [::rss-synd::xml_list_create $sampleFeed]
array set feed {}
set feed(announce-output) 2
set feed(trigger-output) 3
::rss-synd::feed_info $parsedFeed feed

# Test: xml_list_create kann Werte korrekt auslesen
set titlePath [::rss-synd::xml_join_tags $feed(tag-feed) $feed(tag-list) 1 $feed(tag-name) 0 title]

test xml_list_create_extracts_second_title {Der zweite Item-Titel kann gelesen werden} -body {
    set titleChildren [::rss-synd::xml_get_info $parsedFeed $titlePath children]
    ::rss-synd::xml_list_flatten $titleChildren
} -result "Zweiter"

# Test: feed_trim begrenzt Items auf gewünschte Anzahl
set trimmedFeed [::rss-synd::feed_trim $parsedFeed feed 2]
set countPath [::rss-synd::xml_join_tags $feed(tag-feed) $feed(tag-list) -1 $feed(tag-name)]

test feed_trim_limits_items {feed_trim reduziert die Item-Anzahl} -body {
    ::rss-synd::xml_get_info $trimmedFeed $countPath
} -result 2

# Test: Metadaten wie der Kanal-Titel bleiben nach dem Trimmen erhalten
set channelTitlePath [::rss-synd::xml_join_tags $feed(tag-feed) 0 channel 0 title]

test feed_trim_keeps_channel_title {Kanal-Titel bleibt nach dem Trimmen verfügbar} -body {
    set channelChildren [::rss-synd::xml_get_info $trimmedFeed $channelTitlePath children]
    ::rss-synd::xml_list_flatten $channelChildren
} -result "Demo"

# Test: resolve_redirect löst relative Pfade korrekt auf
if {[catch {package require uri}]} {
    puts "Warnung: uri-Paket nicht verfügbar, Redirect-Test übersprungen"
} else {
    namespace eval ::rss-synd { set packages(uri) 0 }
    test resolve_redirect_relative {Relative Redirects werden korrekt aufgelöst} -body {
        ::rss-synd::resolve_redirect "http://example.com/path/feed" "../other.xml"
    } -result "http://example.com/other.xml"
}

test resolve_redirect_fallback {Fallback-Auflösung ohne uri-Paket funktioniert} -body {
    namespace eval ::rss-synd { set packages(uri) 1 }
    ::rss-synd::resolve_redirect "http://example.com/base/index" "relative.xml"
} -result "http://example.com/base/relative.xml"

test resolve_redirect_fallback_parent {Fallback-Auflösung unterstützt '..'} -body {
    namespace eval ::rss-synd { set packages(uri) 1 }
    ::rss-synd::resolve_redirect "http://example.com/base/dir/index" "../next.xml"
} -result "http://example.com/base/next.xml"

# Test: xml_list_create kann auf Teilbereiche beschränkt werden
set childXml "<root><entry>A</entry><entry>B</entry></root>"
set startIndex [string first "<entry>B" $childXml]
set endIndex [string first "</entry>" $childXml $startIndex]
set endIndex [expr {$endIndex + [string length "</entry>"] - 1}]
set partial [::rss-synd::xml_list_create $childXml $startIndex $endIndex]

test xml_list_create_partial_range {Teilbereiche werden korrekt geparst} -body {
    set children [::rss-synd::xml_get_info $partial [list 0 entry] children]
    ::rss-synd::xml_list_flatten $children
} -result "B"

set savedRss {}

test feed_get_rotates_user_agent_list {User-Agent-Rotation liefert unterschiedliche Werte} -setup {
    set savedRss [namespace eval ::rss-synd { array get rss }]
    namespace eval ::rss-synd { array set rss {} }
    namespace eval ::rss-synd {
        variable rss
        set rss(rotation-test) [list \
            "user-agent" {"Agent/1.0" "Agent/2.0" "Agent/3.0"} \
            "user-agent-rotate" "list" \
            "announce-type" 0 \
            "update-interval" 0 \
            "timeout" 1000 \
            "url" "http://example.test/feed" \
            "url-auth" "" \
            "updated" 0 \
        ]
    }
    namespace eval ::http {
        set lastUserAgents {}
        set tokenCounter 0
    }
} -body {
    for {set idx 0} {$idx < 3} {incr idx} {
        namespace eval ::rss-synd {
            array set tmp $rss(rotation-test)
            set tmp(updated) 0
            set rss(rotation-test) [array get tmp]
            unset tmp
        }
        ::rss-synd::feed_get
    }
    namespace eval ::http { set lastUserAgents }
} -cleanup {
    namespace eval ::rss-synd {
        array set rss {}
    }
    if {[llength $savedRss] > 0} {
        namespace eval ::rss-synd { array set rss $savedRss }
    }
    namespace eval ::http {
        set lastUserAgents {}
        set tokenCounter 0
    }
} -result {Agent/1.0 Agent/2.0 Agent/3.0}

test next_user_agent_without_rotation_returns_first_value {Ohne Rotation wird der erste Eintrag genutzt} -body {
    array set feed {user-agent {"Agent/1" "Agent/2"}}
    set first [::rss-synd::next_user_agent sample feed]
    list $first [info exists feed(user-agent-rotate-index)] [info exists feed(user-agent-last)]
} -cleanup {
    catch {unset feed}
} -result {Agent/1 0 1}

test next_user_agent_custom_command_updates_state {Benutzerdefinierte Rotation kann Status hinterlegen} -setup {
    namespace eval ::uaTest {
        variable idx 0
        proc next {feedName settings} {
            variable idx
            incr idx
            return [dict create user-agent [format "CmdUA/%d" $idx] user-agent-rotate-index $idx]
        }
    }
} -body {
    array set feed {user-agent "Fallback/0" user-agent-rotate ::uaTest::next}
    set first [::rss-synd::next_user_agent cmd feed]
    set state1 [list $first $feed(user-agent-rotate-index)]
    set second [::rss-synd::next_user_agent cmd feed]
    set state2 [list $second $feed(user-agent-rotate-index)]
    list $state1 $state2
} -cleanup {
    catch {namespace delete ::uaTest}
    catch {unset feed}
} -result {{CmdUA/1 1} {CmdUA/2 2}}

cleanupTests
