package require tcltest 2
namespace import ::tcltest::*

# Stubs für Eggdrop-spezifische Funktionen
proc putlog {args} { ::testhelpers::capture_putlog {*}$args }
proc putserv {args} {}
proc botonchan {chan} { return 1 }
proc is_utf8_patched {} { return 0 }
proc bind {args} {}
proc unbind {args} {}
proc unixtime {} { clock seconds }

namespace eval ::testhelpers {
    variable logMessages {}

    proc capture_putlog {args} {
        variable logMessages
        set text [join $args " "]
        lappend logMessages $text
    }

    proc dummy_timer {args} {
        return {}
    }

    proc reset_logs {} {
        variable logMessages
        set logMessages {}
    }

    proc get_logs {} {
        variable logMessages
        return $logMessages
    }
}

set here [file dirname [info script]]
namespace eval ::rss-synd {}
source [file join $here .. rss_synd.tcl]

namespace eval ::http {
    variable lastUserAgents {}
    variable tokenCounter 0

    proc config {args} {
        variable lastUserAgents
        set index [lsearch -exact $args "-useragent"]
        if {$index >= 0} {
            lappend lastUserAgents [lindex $args [expr {$index + 1}]]
        }
        return {}
    }

    proc geturl {url args} {
        variable tokenCounter
        incr tokenCounter
        return "token$tokenCounter"
    }

    proc register {args} { return {} }
    proc unregister {args} { return {} }
}

namespace eval ::tls {
    variable debugCalls {}

    proc init {args} { return {} }
    proc debug {flag} {
        variable debugCalls
        lappend debugCalls $flag
        return {}
    }
    proc socket {args} { return sock }
}

namespace eval ::rss-synd { variable packages }

test configure_debug_all_enables_http_and_tls {Konfiguration "all" aktiviert HTTP- und TLS-Debug-Flag} -setup {
    namespace eval ::rss-synd { catch {array unset debugOptions} }
} -body {
    ::rss-synd::configure_debug [list debug-mode {all}]
    namespace eval ::rss-synd { list $debugOptions(http) $debugOptions(tls) }
} -cleanup {
    namespace eval ::rss-synd { array set debugOptions {http 0 tls 0} }
} -result {1 1}

test setup_tls_calls_tls_debug_when_enabled {TLS-Debug wird aktiviert und protokolliert} -setup {
    namespace eval ::rss-synd { catch {array unset debugOptions} }
    namespace eval ::tls { set debugCalls {} }
    ::testhelpers::reset_logs
} -body {
    ::rss-synd::configure_debug [list debug-mode {tls}]
    ::testhelpers::reset_logs
    ::rss-synd::setup_tls
    set debugCount [llength [namespace eval ::tls { set debugCalls }]]
    set logs [::testhelpers::get_logs]
    set found 0
    foreach entry $logs {
        if {[string match *TLS-Debugmodus* $entry]} {
            set found 1
        }
    }
    list $debugCount $found
} -cleanup {
    namespace eval ::rss-synd { array set debugOptions {http 0 tls 0} }
    ::testhelpers::reset_logs
} -result {1 1}

test feed_get_emits_http_debug_log_when_enabled {HTTP-Debug protokolliert URL, Timeout und Header} -setup {
    set savedRssExists [namespace eval ::rss-synd { array exists rss }]
    if {$savedRssExists} {
        set savedRss [namespace eval ::rss-synd { array get rss }]
    } else {
        set savedRss {}
    }
    namespace eval ::rss-synd {
        catch {array unset rss}
        array set rss {}
        set rss(debugfeed) [list \
            "url" "http://example.test/feed" \
            "timeout" 4200 \
            "update-interval" 0 \
            "announce-type" 0 \
            "trigger-type" "0:2" \
            "user-agent" {"Agent/1"} \
            "user-agent-rotate" "" \
            "url-auth" "dGVzdDp0b2tlbg==" \
            "enable-gzip" 1 \
            "updated" 0 \
            "max-depth" 5 \
        ]
    }
    ::testhelpers::reset_logs
    namespace eval ::http { set tokenCounter 0 }
} -body {
    ::rss-synd::configure_debug [list debug-mode {http}]
    ::testhelpers::reset_logs
    ::rss-synd::feed_get
    set logs [::testhelpers::get_logs]
    set idx [lsearch -glob $logs "*HTTP GET*http://example.test/feed*"]
    set hasMsg [expr {$idx >= 0}]
    set headersLogged 0
    if {$hasMsg} {
        set entry [lindex $logs $idx]
        if {[string match *timeout=4200* $entry] && [string match *Authorization* $entry] && [string match *Accept-Encoding* $entry]} {
            set headersLogged 1
        }
    }
    list $hasMsg $headersLogged
} -cleanup {
    namespace eval ::rss-synd {
        catch {array unset rss}
        if {$savedRssExists} {
            array set rss $savedRss
        }
        array set debugOptions {http 0 tls 0}
    }
    ::testhelpers::reset_logs
} -result {1 1}

set sampleFeed {<rss><channel><title>Demo</title><item><title>Erster</title></item><item><title>Zweiter</title></item><item><title>Dritter</title></item></channel></rss>}

set parsedFeed [::rss-synd::xml_list_create $sampleFeed]
array set feed {}
set feed(announce-output) 2
set feed(trigger-output) 3
::rss-synd::feed_info $parsedFeed feed

# Test: xml_list_create kann Werte korrekt auslesen
set titlePath [::rss-synd::xml_join_tags $feed(tag-feed) $feed(tag-list) 1 $feed(tag-name) 0 title]

test xml_list_create_extracts_second_title {Der zweite Item-Titel kann gelesen werden} -body {
    set titleChildren [::rss-synd::xml_get_info $parsedFeed $titlePath children]
    ::rss-synd::xml_list_flatten $titleChildren
} -result "Zweiter"

# Test: feed_trim begrenzt Items auf gewünschte Anzahl
set trimmedFeed [::rss-synd::feed_trim $parsedFeed feed 2]
set countPath [::rss-synd::xml_join_tags $feed(tag-feed) $feed(tag-list) -1 $feed(tag-name)]

test feed_trim_limits_items {feed_trim reduziert die Item-Anzahl} -body {
    ::rss-synd::xml_get_info $trimmedFeed $countPath
} -result 2

# Test: Metadaten wie der Kanal-Titel bleiben nach dem Trimmen erhalten
set channelTitlePath [::rss-synd::xml_join_tags $feed(tag-feed) 0 channel 0 title]

test feed_trim_keeps_channel_title {Kanal-Titel bleibt nach dem Trimmen verfügbar} -body {
    set channelChildren [::rss-synd::xml_get_info $trimmedFeed $channelTitlePath children]
    ::rss-synd::xml_list_flatten $channelChildren
} -result "Demo"

# Test: resolve_redirect löst relative Pfade korrekt auf
if {[catch {package require uri}]} {
    puts "Warnung: uri-Paket nicht verfügbar, Redirect-Test übersprungen"
} else {
    namespace eval ::rss-synd { set packages(uri) 0 }
    test resolve_redirect_relative {Relative Redirects werden korrekt aufgelöst} -body {
        ::rss-synd::resolve_redirect "http://example.com/path/feed" "../other.xml"
    } -result "http://example.com/other.xml"
}

test resolve_redirect_fallback {Fallback-Auflösung ohne uri-Paket funktioniert} -body {
    namespace eval ::rss-synd { set packages(uri) 1 }
    ::rss-synd::resolve_redirect "http://example.com/base/index" "relative.xml"
} -result "http://example.com/base/relative.xml"

test resolve_redirect_fallback_parent {Fallback-Auflösung unterstützt '..'} -body {
    namespace eval ::rss-synd { set packages(uri) 1 }
    ::rss-synd::resolve_redirect "http://example.com/base/dir/index" "../next.xml"
} -result "http://example.com/base/next.xml"

# Test: xml_list_create kann auf Teilbereiche beschränkt werden
set childXml "<root><entry>A</entry><entry>B</entry></root>"
set startIndex [string first "<entry>B" $childXml]
set endIndex [string first "</entry>" $childXml $startIndex]
set endIndex [expr {$endIndex + [string length "</entry>"] - 1}]
set partial [::rss-synd::xml_list_create $childXml $startIndex $endIndex]

test xml_list_create_partial_range {Teilbereiche werden korrekt geparst} -body {
    set children [::rss-synd::xml_get_info $partial [list 0 entry] children]
    ::rss-synd::xml_list_flatten $children
} -result "B"

set savedRss {}

test feed_get_rotates_user_agent_list {User-Agent-Rotation liefert unterschiedliche Werte} -setup {
    set savedRss [namespace eval ::rss-synd { array get rss }]
    namespace eval ::rss-synd { catch {array unset rss} }
    namespace eval ::rss-synd {
        variable rss
        set rss(rotation-test) [list \
            "user-agent" {"Agent/1.0" "Agent/2.0" "Agent/3.0"} \
            "user-agent-rotate" "list" \
            "announce-type" 0 \
            "update-interval" 0 \
            "timeout" 1000 \
            "url" "http://example.test/feed" \
            "url-auth" "" \
            "updated" 0 \
        ]
    }
    namespace eval ::http {
        set lastUserAgents {}
        set tokenCounter 0
    }
} -body {
    for {set idx 0} {$idx < 3} {incr idx} {
        namespace eval ::rss-synd {
            array set tmp $rss(rotation-test)
            set tmp(updated) 0
            set rss(rotation-test) [array get tmp]
            unset tmp
        }
        ::rss-synd::feed_get
    }
    namespace eval ::http { set lastUserAgents }
} -cleanup {
    namespace eval ::rss-synd { catch {array unset rss} }
    if {[llength $savedRss] > 0} {
        namespace eval ::rss-synd { array set rss $savedRss }
    }
    namespace eval ::http {
        set lastUserAgents {}
        set tokenCounter 0
    }
} -result {Agent/1.0 Agent/2.0 Agent/3.0}

test next_user_agent_without_rotation_returns_first_value {Ohne Rotation wird der erste Eintrag genutzt} -body {
    array set feed {user-agent {"Agent/1" "Agent/2"}}
    set first [::rss-synd::next_user_agent sample feed]
    list $first [info exists feed(user-agent-rotate-index)] [info exists feed(user-agent-last)]
} -cleanup {
    catch {unset feed}
} -result {Agent/1 0 1}

test next_user_agent_custom_command_updates_state {Benutzerdefinierte Rotation kann Status hinterlegen} -setup {
    namespace eval ::uaTest {
        variable idx 0
        proc next {feedName settings} {
            variable idx
            incr idx
            return [dict create user-agent [format "CmdUA/%d" $idx] user-agent-rotate-index $idx]
        }
    }
} -body {
    array set feed {user-agent "Fallback/0" user-agent-rotate ::uaTest::next}
    set first [::rss-synd::next_user_agent cmd feed]
    set state1 [list $first $feed(user-agent-rotate-index)]
    set second [::rss-synd::next_user_agent cmd feed]
    set state2 [list $second $feed(user-agent-rotate-index)]
    list $state1 $state2
} -cleanup {
    catch {namespace delete ::uaTest}
    catch {unset feed}
} -result {{CmdUA/1 1} {CmdUA/2 2}}

test settings_loading_failure_aborts_execution {Fehlende Einstellungen brechen das Laden mit aussagekräftiger Meldung ab} -setup {
    set tmpdir [file normalize [file join $here tmp-missing-settings]]
    file delete -force $tmpdir
    file mkdir $tmpdir
    set scriptPath [file normalize [file join $tmpdir rss_synd.tcl]]
    file copy -force [file join $here .. rss_synd.tcl] $scriptPath
    namespace eval ::testhelpers { reset_logs }
    interp create rssFail
    interp alias rssFail putlog {} ::testhelpers::capture_putlog
    interp alias rssFail utimer {} ::testhelpers::dummy_timer
    interp alias rssFail killutimer {} ::testhelpers::dummy_timer
    set expectedPath [file normalize [file join [file dirname $scriptPath] rss-synd-settings.tcl]]
    set expectedError [format {couldn't read file "%s": no such file or directory} $expectedPath]
} -body {
    set result [catch {interp eval rssFail [list source $scriptPath]} msg opts]
    set logs [::testhelpers::get_logs]
    set expectedLog [format "Error: Could not load settings file '%s': %s" $expectedPath $msg]
    list $result [string equal $msg $expectedError] [llength $logs] [string equal [lindex $logs 0] $expectedLog]
} -cleanup {
    interp delete rssFail
    file delete -force $tmpdir
} -result {1 1 1 1}

cleanupTests
